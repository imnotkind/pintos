Brief problem description
	현재 timer_sleep() 함수는 매 틱마다 처음 정한 시간이 지났는지 확인하여 지나지 않았으면 자신에게 할당된 시간을 다른 스레드에게 돌린다. sleep 함수는 해당 스레드가 자원을 점유하지 않게 하기 위해 존재하는 기능인데, 이같이 구현하면 스레드가 자원을 점유하지 않게 하기 위해 해당 스레드가 자원을 점유해야 한다는 모순이 생긴다. 이는 컴퓨터의 성능에 악영향을 미친다.
Current implementation in source codes and how it works
	timer_sleep (int64_t ticks) 
	{
	  int64_t start = timer_ticks ();

	  ASSERT (intr_get_level () == INTR_ON);
	  while (timer_elapsed (start) < ticks) 
	    thread_yield ();
	}
	
	먼저, start 변수에 현재 틱을 집어넣는다. 이후 assert 함수로 에러 체크를 한 뒤, timer_elapsed로 start 이후로 흐른 시간을 체크하여 목표 틱 수인 ticks보다 작으면 스레드가 자원을 포기하고, 아니면 함수를 종료하여 유휴 상황에서 빠져나온다.
How to solve
	thread_yield가 아니라 thread_block을 이용하여 스레드를 아예 정지시키고, 시스템 스레드에서 thread_unblock을 이용하여 풀어주도록 하자.
Data structure & algorithms
	sleep 함수가 호출되면 스레드의 이름과 깨어나야 할 ticks을 따로 저장한다. 여러 스레드가 동시에 sleep 될 수 있으니 힙을 만들어 깨어나는 순서대로 저장하면 편할 것이다. 이후 스레드를 블록한다. 현재 시스템의 ticks을 확인하여 힙의 가장 위에 있는 목표 ticks보다 크면 이를 꺼내 해당 스레드에 thread_unblock을 하는 함수를 만든다. 타이머 처리를 전문으로 하는 시스템 함수에 해당 함수를 넣는다.