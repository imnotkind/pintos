Project #1 Design Report : 
  (3/3/2/3) Overall comment: 
  설명이 조금 더 자세할 필요가 있습니다. 
  어떤 구조체, 함수를 추가/고쳐야 하는지도 명시해주어야 합니다. 
  예를들어 load_avg 는 global variable 로 선언해야 하나요? 
  Prob2. Donation을 위한 방법이 더 필요합니다.

Project #2 Design Report :
"arg.passing: arg들을 stack에 저장하는 기준과 방법에 대한 상세한 설명이 필요합니다. 
syscall: 전체적으로 설명이 빈약합니다. 각 syscall의 역할 뿐 아니라 고려해야 하는 조건 등에 대해 서술해주셔야 합니다. 특히 exit, wait 등은 깊은 고찰이 필요합니다. 예를 들면, exit시, parent가 wait중인 경우도 고려해야 합니다. wait시 process를 block, unblock하는 방법에 대해 생각해보세요. child가 wait되면 안되는 조건에 대해 고려해야 합니다. open된 file들을 관리하는 방법을 생각해보세요."


안녕하세요.
프로젝트 3번에 대한 질문과 답변을 공유해드립니다.


1. 유저 프로세스 메모리와 페이징

페이징은 메모리를 관리하는 메커니즘의 일종입니다.
따라서 유저 프로세스 메모리와 페이징은 서로 다른 이야기입니다.


2. 가상 메모리와 물리 메모리의 차이

가상 메모리는 유저 프로세스가 시스템 메모리를 바라 보는 관점입니다.
따라서 유저 프로세스는 자신이 온전히 4GB 의 메모리를 소유하고 있다고 생각합니다.
그러나 모든 프로세스가 실제로 4GB 의 메모리를 소유 할 수는 없기 때문에
페이징과 같은 방식으로 이를 물리 메모리와 매칭시켜서 유저 프로세스에게
가상화 된 메모리 영역을 제공하는 것입니다.
따라서 유저 프로세스가 가상 메모리를 나누어 가지는 것이 아니라
매핑을 통해 물리 메모리를 나누어 가진다고 생각하시면 되고
사실 이 또한 swap 때문에 정확한 표현은 아닙니다


3. Heap, stack, code 와 같은 구간과 페이징의 관계

페이징은 메모리를 일정한 크기의 블록(페이지)로 나누어 관리합니다.
따라서 기존의 유저 프로세스에서 heap, stack 등과 같은 메모리 구역 또한 페이징 될 수 있습니다.
이 과정에서 메모리 구역이 페이지 단위로 딱 맞아 떨어지지 않으므로 단편화 문제가 발생하게 됩니다.


4. 커널 영역과 유저 영역

페이징을 하더라도 유저 프로세스가 메모리를 접근 할 때 커널 영역과 유저 영역을 구분하여야 합니다.


5. 프로젝트 3번 문서에서 expected entry 중 possbility of allocation

possibility 라는 표현보단 availability 라는 표현이 더 적절 할 것 같습니다.
프레임이나 페이지를 추가로 할당 할 수 있는지에 관한 문제입니다.
다만 실제로 구현 하실 때 문서에 있는 것들을 반드시 모두 포함해야 한다고 생각하시기보단
요구하는 기능을 충족시키기 위해 직접 디자인을 하시면서 필요하다고 생각하시는 것을
사용하시면 될 것 같습니다


6. Extra credit

이번 프로젝트 3 에서 pintos 도큐먼트에 따르면 sharing 에 대한 extra credit 을 언급하고 있는데
본 수업에서는 테스트 케이스를 통한 P/F 로 점수를 측정하므로
테스트 케이스에 영향을 주지 않는 extra 기능은 구현하지 않으셔도 됩니다.
또한 해당 기능은 채점되지 않습니다.
